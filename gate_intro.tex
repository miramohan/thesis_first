\chapter{GATE LEVEL SIMULATION}
\label{chap:gate_intro.tex}

In a typical VLSI design flow for verification, the first step after RTL level model of the design availabilty is writing behavioral test bench for functional verification. The functionally verified RTL goes through design synthesis during which it is mapped into low level design components in terms of primitives or logic gates. Synthesis is mostly an automated process using a ``{\it synthesizer}'' tool that converts RTL-level design source code into corresponding gate-level netlist mappings. This netlist is also called the pre-layout netlist.

The pre-layout netlist that was obtained from synthesis is then fed into a layout tool which maps the gate primities to silicon structures such as channels, gates, vias, etc. During this process certain modifications are done on netlist but it should not alter its functionality to its corresponding RTL. To validate this, another netlist called the post-layout netlist is generated back from the layed-out silicon structures by the layout tool itself. Validation is made by running LEC tool over both pre-layout and post-layout netlists or between post-layout netlist and RTL.

Though it would be ideal to use post-layout netlist for the purpose of gatesims, it would be too late in the design process. So work on gatesims starts with pre-layout netlist and progresses to post-layout netlist as it becomes available. ~\figurename{~\ref{fig:vlsi_design.ps}} depicts progress of gatesim with respect to other design flows.

%\figurename{} 
\begin{figure}[h]
\centering
\includegraphics[width=3.5in]{./figures/vlsi_design.ps}
\caption{Design Flow}
\label{fig:vlsi_design.ps}
\end{figure}
Gate Level Simulation or Gatesim focuses on verifying the post layout netlist of the design. Gatesims are historically present from the days when designs were done with gates rather than at RTL abstraction. Verification with gates is a huge confidence builder before manufacturing of actual silicon as they are also thought to complement and reassure results obtained from formal flow.


\section {NEED FOR GATESIM}
Gatesims are particularly effective for the following verification
\begin{itemize}
	\item[-]Power-up, reset propagation and initialization of the design
%% Naren:isitso?:	\item[-]The RTL written is synthesizable.
	\item[-]DFT structures those are absent in RTL and added during or after synthesis
	\item[-]non-resettable or un-initialized components such as memories
%% Naren:what?:	\item[-]The netlist passes all the critical test scenarios.
	\item[-]Power related circuits those are absent in RTL
	\item[-]Power switching verification
	\item[-]Dynamic power estimation
	\item[-]Validation of pessimistic behaviour of X-propagation in RTL simulation
	\item[-]Asynchronous interfaces those are false-paths in STA
	\item[-]Synchroniser logic and clock domain crossing verification
	\item[-]Analog-circuit and digital circuit co-verification
\end{itemize}

Finally, Gatesim is a great confidence-booster in ensuring the high quality of the netlist. It lowers the risk of finding design, methodology or process issues in silicon.




\section{LIMITATIONS OF LEC AND STA}

Gatesims are targetted on post-layout netlist and that is almost clean of RTL bugs. The netlist also passes through couple of important verification steps such as Logic Equivalence Check (LEC) and Static Timing Analysis (STA), before it is targeted for Gatesims.

\emph {\bf LEC}: Logic Equivalence Check (LEC) is a formal verification tool that compares a reference design against a derived design to prove equivalence or to report differences.  LEC does not require test patterns. Instead, LEC uses Boolean arithmetic techniques to prove equivalence between two design descriptions\cite{ieee:boolean}. Although LEC uses sophisticated formal algorithms to identify, map, and compare nodes in the netlists, the complexity is hidden from the user\cite{lec}. %meera: what's this: [ieee] @naren: updated with cite for ieee page..

\emph {\bf STA}: Static Timing Analysis does a input-independent timing analysis of the gate level netlist. It asserts if the circuit could operate flawless without timing issues. It computes the worst-case behaviour of the circuit, over all possible manufacturing variables. STA tools are at ease in handling a complex design with huge number of paths as they consider one path at a time (whether they are real or potential false paths). 



These formal static verification techniques are much faster and evolved than simulation based methods. However these verification methodologies, in spite of advancements in tools, cannot cover all verification requirements on netlist. In addtition to reassuring results obtained by formal methods, gatesim helps in filling up the gaps left by these methods. 

Limitations of LEC, which could be covered by Gatesims are:
\begin{itemize}
	\item Limitation of Static Equivalence Checking tools to catch all X-propagation or X-generation issues.
	\item Two-state methodologies can miss RTl-versus-netlist simulation and RTL-versus-RTL simulation differences.
	\item Incorrect mapping issues due to naming at sub-block level which can result in false pass. This will not be reported at the sub-block level LEC, but Gatesims can flag such incorrect connectivity.
\end{itemize}

Limitations of STA, which could be covered by Gatesims are:
\begin{itemize}
	\item \emph{\bf X-propogation:} STA deals only with logic domain of logic-0 and logic-1. There could be many sources of indeterministic states in the design such as uninitialized flops, output of memories, synchronisers, etc. Such indeterministic state value ($X$), could propagate through and cause failure of operation. Gatesim acurately models this behaviour and but STA does not.
	\item \emph{\bf Asynchronous Interfaces:} STA ignores certain asynchronous paths called as ``false paths'', like with analog blocks or primary IO's. And hence, STA cannot verify timing between digital and analog blocks whereous Gatesims could.
	\item \emph{\bf Reset sequence:} Verifying that all flip-flops resets into their required logical value. STA cannot check this as certain declarations such as initial values on signal are not synthesizable and are verified only during simulation.
	\item \emph{\bf Asynchronous clock-domain crossings:} STA does not check if the indeterministic value $X$ produced for one clock cycle when logic passes clock domains, is suppressed or not.
\end{itemize}








\section{ISSUES CAUGHT BY GATESIM}
Some of the design flaws, those missed by other methods but caught by gatesims:
\begin{enumerate}

\item \emph{\bf $X$-Squashing}
	$X$-Squashing is a terminology to denote when uninitialised state value $X$ get wrongly suppressed in simulation and does not propagate anymore through the logic, which it should have. In one case there was an $X$-Squashing issue in behavioral RTL where the issue should have been found but a valid value was present, it was later found in gatesims.

\item \emph{\bf Glitches}
	Glitches are produced by combinational logic, and are not of concern in synchronous circuits as they are suppressed before next clock. Glitches in clock and reset paths are of concern. Here all methodologies fall short and gatesims are good in finding such issues.

\item \emph{\bf Uninitialized states in design}
	Source of un-initialized design states ($X$) could be easily found in gatesims. After identifying such scenarios appropriate initialization modelling needs to be performed to proceed with Gate simulation flow.

\item \emph{\bf Partitioning Issues}
	Design is partitioned to ease front-end design flows such as synthesis, STA, layout and LEC. Such act introduces discontinuity in such flows such as wrong constraints for different partitions and so forth. Gatesims are good at catching such issues, if appropriate stimulus is chosen.

\end{enumerate}







\section{ISSUES FACED BY GATESIM}
\label{intro:sec:ifg}
At system level, Gatesim is one of the most challenging verification task. This is because as design complexity increases, the limitations with gatesims become more prominent. Important difficulties associated with gate level simulation are:
\begin{itemize}


\item[-] Larger turn-around time (run, debug cycle).
\item[-] Limitation on size of netlist that can be verified through gatesim. This is an indirect cause due to larger build times and run times.
\item[-] Debugging the netlist simulation is challenging.
\item[-] Large compute and storage resource requirements. 

\end{itemize}

