\chapter{INTRODUCTION}
%\section{Background}
%\section{Purpose/Motivation}
%\section{Approach}
%\section{Main Contributions}
%\section{Organization of thesis}


With rapid growth of deep sub micron technology, there has been an aggressive shrinking in physical dimension of silicon structures that can be realized on silicon. This advancement has enabled the transition of multi million gate designs from large printed circuit boards to SoC (System on Chip)\nomenclature{SoC}{System on Chip}. SoC design has the advantages of smaller size, lower power consumption, reliability, performance improvement and low cost per gate. Another major high point of SoC from design point of view is that SoC allows use of pre-designed blocks called semiconductor Intellectual Property (IP)\nomenclature{IP}{Intellectual Property}. These hardware IP blocks can be mix-and-matched, thereby providing design reuse in SoC and thus reducing time-to-market~\citep{ieee:SOC:2010}. 


 Over the past few years, major challenges faced by semiconductor industry has been to develop more complex SoCs with greater functionality and diversity with reduction in time-to-market. One of the main challenge among this is verification~\citep{soc}. Integration between various components, complexity of multiple sub-systems, software-hardware co-verification makes SoC verification very challenging. It has been widely accepted that verification consumes more than 70 percent of design effort~\citep{phd:zhang}. This can be easily explained as there is no single design tool that can completely verify a SoC on it's own. Instead a complex sequence of tools and techniques including stimulus based (directed and random verification) and formal verification are used to verify a SoC.  Even then achieving cent percent functional verification coverage is next to impossible due to time-to-market constraints.


\section{VERIFICATION METHODS}
Two widely adopted verification methodologies are stimulus based dynamic verification methodology and static formal verification methodology. In stimulus based verification methodology, the verification engineer develops a set of tests based on design specifications. Design correctness is then established through simulations. On the other hand formal verification is a mathematical proof method of ensuring that a design's implementation matches its specification~\citep{ieee:segev:2004}. The most prominent distinction between these two methods is that while stimulus based method requires input vectors, formal methods do not. In stimulus based verification the idea is to first generate input vectors and then compute the design response where as in formal verification process it is the reverse approach.

In formal verification the behavior of design is captured as a set of mathematical equations called properties and then the formal verification tool proves or disproves each property appropriately. Here, user need not generate stimulus but specification of invalid stimulus would be necessary. However formal methodology tools have large memory and long run time requirements.  When memory capacity is exceeded, these tools often describe what went wrong but provide little guidance to fix the problem. As a result, formal verification methodologies are best suited only to circuits of moderate size, such as blocks or modules. As a result, formal verification methodologies are best suited only to circuits of moderate size, such as blocks or modules. Since SoC level designs are huge, these are typically beyond the capacities of automatic formal tools~\citep{ieee:formal:2004}. 

\section{SoC VERIFICATION}
Most SoCs are built around one or more processing cores and verification is done using stimulus based verification methodology where the design model is simulated using random or directed test-vectors. Reference models are simulated in parallel with the design and results are compared.  Comparison between the design architecture state and the reference model states are done after each instruction retire. Difference detected in states is considered as ``{\it mismatches}''. Memory contents are compared at the end of simulation and all discrepancies are reported as ``{\it memory mismatches}''.  The reference model writes entries for each event it processes into processor execution log file.

On event of a simulation mismatch, the processor execution log entries are helpful in understanding and tracing the cause associated with the failure. Logs contain in-depth details pertaining to processor execution. 

\section{PROPOSED ENHANCEMENT TO AID PROCESSOR EXECUTION DEBUG}
Tracing a typical failure is a manual process and is time consuming as relevant information could be buried under a wealth of information or spread across in different files. This greatly challenges an engineer's ability to debug and converge on the cause. If there exists an interface which correlates different information and presents them as required by the verification engineer it would aid debug significantly. The proposed interactive interface provides graphical data representations and navigation, helping in faster tracing through processor execution. Such represented information is correlated, filtered and sorted making debugging a lot more intuitive than existing manual method.


Such graphical user interface is proposed to aid processor execution debug by representation of data to user. This interface needs to perform the duties of a software debugger but it should work offline. This project work concentrates on implementing such an enhancement.

 


\section{ORGANIZATION OF THE THESIS}
The organization of this project report is as follows:\\
\noindent 
{\bf Chapter}~\ref{chap:amd64}-{\it AMD64 Architecture Overview} gives brief introduction to AMD64 architecture.\\
{\bf Chapter}~\ref{chap:verification.tex}-{\it Verification Environment} discusses existing verification methodologies and their shortfalls.\\
{\bf Chapter}~\ref{chap:enhancement.tex}-{\it Proposed Enhancement} discusses desired features of proposed enhancement.\\
{\bf Chapter}~\ref{chap:GUI_impl.tex}-{\it Interface Implementation} gives implementation details of proposed enhancement.\\
{\bf Chapter}~\ref{chap:GUI_results.tex}-{\it Implementation Results} a final look at the implemented enhancement.\\
{\bf Chapter}~\ref{chap:conclusion} discusses the various conclusion drawn from the results and the scope for future work.

