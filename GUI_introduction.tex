\chapter{INTRODUCTION}
%\section{Background}
%\section{Purpose/Motivation}
%\section{Approach}
%\section{Main Contributions}
%\section{Organization of thesis}

With rapid growth of deep sub micron technology, there has been an aggressive shrinking in physical dimension of silicon structures, that can be realized on silicon. This advancement has enabled the transition of multi-million gate designs from large printed circuit boards to SoC (System on Chip) \nomenclature{SoC}{System on Chip}. SoC design has the advantages of smaller size, low power consumption, reliability, performance improvement and low cost per gate. Another major high point of SoC from design point of view is that SoC allows use of predesigned blocks called semiconductor intellectual property (IP) \nomenclature{IP}{intellectual Property}. These hardware IP blocks can be mix-and-matched, thereby providing design reuse in SoC and thereby reducing time-to-market. 


 Over the past few years, major challenges faced by semiconductor industry is to develop more complex SoCs with greater functionality and diversity with reduction in time-to-market. One of the main challenge among this is verification. Integration between various components, combined complexity of multiple sub-systems, software-hardware co-verification, conflicts in accessing shared resource, arbitration problems and dead-locks, priority conflicts in exception handling etc makes SoC verification very hard. It is said that verification consumes more than 60 percent of design effort. This can be easily explained as there is no single design tool that can completely verify a SoC on it's own. Instead a complex sequence of tools and techniques, including simulation, directed and random verification and formal verification are used to verify a SoC. Achieving cent percent functional verification coverage is next to impossible due to time-to-market constraints.


\section{VERIFICATION METHODS}
Two widely adopted verification methodologies are stimulus based dynamic verification methodology and static formal verification methodology. In stimulus based verification the verification engineer develops a set of tests, based on design specifications. Design correctness is then established through simulations. Formal verification is a mathematical proof method of ensuring that a design's implementation matches its specification. The most prominent distinction between stimulus-based verification and formal verification is that the former requires input vectors and the latter does not. In stimulus based verification the idea is to first generate input vectors and then derive the reference output where as in formal verification process it is the reverse approach.

In formal verification the behavior of design is captured as a set of mathematical equations called properties and then the formal verification tool proves or disproves each property appropriately. In formal verification, user need not generate stimulus but specification of invalid stimulus would be necessary.  At SoC level the designs are huge, typically beyond the capacities of automatic formal tools. Formal methodology tools have large memory and long run time requirements. When memory capacity is exceeded, tools often shed little light on what went wrong, or give little guidance to fix the problem. As a result, formal verification software, is best suited only to circuits of moderate size, such as blocks or modules. 

\section{SoC VERIFICATION}
Most SoCs are built around one or more processing cores (multi processor) and verification is done using stimulus based verification methodology where the design model is simulated using random or handwritten test programs. Reference models are simulated in parallel with the design and results are compared.  Comparison between the design architecture state and the reference model states are done after each instruction retire. Difference detected in states is considered as ``{\it mismatches}''. Memory contents are compared at the end of simulation and any discrepancies are reported as ``{\it memory mismatches}''.  The simulator writes entries for each event it processes into processor execution log file.

On event of a simulation mismatch, the processor execution log entries are helpful in understanding and tracing the cause associated with the failure. Logs contain in-depth details pertaining to processor execution. 

\section{PROPOSED ENHANCEMENT TO AID PROCESSOR EXECUTION DEBUG}
Tracing a typical failure is a manual process and is time consuming since relevant informations are buried under a wealth of information, and related informations are spread across in different files. This greatly challenges an engineer's ability to debug and converge on the cause. If there exists a representation which correlates different information and presents them as required by the user, it would aid debug significantly. The proposed interactive interface provides graphical data representations and navigation, helping in faster tracing through processor execution. Such represented information is correlated, filtered and sorted making debugging a lot more intuitive than existing manual method.


Such an envisioned graphical user interface is proposed to aid processor execution debug by representation of data to user. This interface would have properties of a software debugger, and it would work offline. This project work concentrates on implementing such an enhancement.

 


\section{ORGANIZATION OF THE THESIS}
The organization of this project report is as follows:\\
\noindent 
{\bf Chapter}~\ref{chap:amd64}-{\it AMD64 Architecture Overview} gives brief introduction to AMD64 architecture.\\
{\bf Chapter}~\ref{chap:verification.tex}-{\it Verification Shortfalls} discusses existing verification methodologies and their shortfalls.\\
{\bf Chapter}~\ref{chap:enhancement.tex}-{\it Proposed Enhancement} discusses desired features of proposed enhancement.\\
{\bf Chapter}~\ref{chap:GUI_impl.tex}-{\it Implementation of Proposed Enhancement} gives implementation details of proposed enhancement.\\
{\bf Chapter}~\ref{chap:GUI_results.tex}-{\it Implementation Results} a final look at the implemented enhancement.\\
%{\bf Chapter}~\ref{chap:conclusion} discusses the various 
%conclusion drawn from the results and the scope for future work.

